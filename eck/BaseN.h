#pragma once
#include "CByteBuffer.h"
#include "CString.h"

ECK_NAMESPACE_BEGIN
namespace Priv
{
    inline constexpr BYTE Base64DecodeTable[]
    {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,

        0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
        0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
        0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
        0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
        0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

    constexpr inline char Base64EncodeTable[]{ "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" };
}

inline void Base64Decode(_In_reads_or_z_(cch) PCCH psz, int cch, CByteBuffer& rb) noexcept
{
    if (cch < 0)
        cch = (int)TcsLen(psz);
    int i{}, j{};
    size_t idxBin{ rb.Size() }, idxText{};
    BYTE temp[4];

    rb.PushBackNoExtra(cch / 4 * 3 + 3);
    while (cch-- && (psz[idxText] != '='))
    {
        temp[i++] = psz[idxText]; idxText++;
        if (i == 4)
        {
            for (i = 0; i < 4; i++)
                temp[i] = Priv::Base64DecodeTable[temp[i]];

            rb[idxBin++] = (temp[0] << 2) + ((temp[1] & 0x30) >> 4);
            rb[idxBin++] = ((temp[1] & 0xf) << 4) + ((temp[2] & 0x3c) >> 2);
            rb[idxBin++] = ((temp[2] & 0x3) << 6) + temp[3];

            i = 0;
        }
    }

    if (i)
    {
        for (j = i; j < 4; j++)
            temp[j] = 0;
        for (j = 0; j < 4; j++)
            temp[j] = Priv::Base64DecodeTable[temp[j]];
        if (i >= 2)
            rb[idxBin++] = (temp[0] << 2) | ((temp[1] & 0x30) >> 4);
        if (i >= 3)
            rb[idxBin++] = ((temp[1] & 0x0F) << 4) | ((temp[2] & 0x3C) >> 2);
        if (i == 4)
            rb[idxBin++] = ((temp[2] & 0x03) << 6) | temp[3];
    }
    rb.ReSize(idxBin);
}

EckInline void Base64Decode(_In_reads_or_z_(cch) const char8_t* psz, int cch, CByteBuffer& rb) noexcept
{
    Base64Decode((PCCH)psz, cch, rb);
}

inline void Base64Encode(_In_reads_bytes_(cb) PCVOID p_, size_t cb, CStringA& rs) noexcept
{
    PCBYTE p = (PCBYTE)p_;
    const auto pDst = rs.PushBackNoExtra(int(4 * ((cb + 2) / 3)));
    int i = 0;
    int j = 0;
    BYTE t3[3];
    BYTE t4[4];
    int pos = 0;

    while (cb--)
    {
        t3[i++] = *(p++);
        if (i == 3)
        {
            t4[0] = (t3[0] & 0xfc) >> 2;
            t4[1] = ((t3[0] & 0x03) << 4) + ((t3[1] & 0xf0) >> 4);
            t4[2] = ((t3[1] & 0x0f) << 2) + ((t3[2] & 0xc0) >> 6);
            t4[3] = t3[2] & 0x3f;

            for (i = 0; (i < 4); i++)
                pDst[pos++] = Priv::Base64EncodeTable[t4[i]];
            i = 0;
        }
    }

    if (i)
    {
        for (j = i; j < 3; j++)
            t3[j] = '\0';

        t4[0] = (t3[0] & 0xfc) >> 2;
        t4[1] = ((t3[0] & 0x03) << 4) + ((t3[1] & 0xf0) >> 4);
        t4[2] = ((t3[1] & 0x0f) << 2) + ((t3[2] & 0xc0) >> 6);
        t4[3] = t3[2] & 0x3f;

        for (j = 0; (j < i + 1); j++)
            pDst[pos++] = Priv::Base64EncodeTable[t4[j]];

        while ((i++ < 3))
            pDst[pos++] = '=';
    }
}

EckInline CByteBuffer Base64Decode(_In_reads_or_z_(cch) PCCH psz, int cch) noexcept
{
    CByteBuffer rb{};
    Base64Decode(psz, cch, rb);
    return rb;
}
EckInline CByteBuffer Base64Decode(_In_reads_or_z_(cch) const char8_t* psz, int cch) noexcept
{
    return Base64Decode((PCCH)psz, cch);
}
EckInline CByteBuffer Base64Decode(const CStringA& rs) noexcept
{
    return Base64Decode(rs.Data(), rs.Size());
}
EckInline void Base64Decode(const CStringA& rs, CByteBuffer& rb) noexcept
{
    Base64Decode(rs.Data(), rs.Size(), rb);
}

EckInline CStringA Base64Encode(_In_reads_bytes_(cb) PCVOID p, size_t cb) noexcept
{
    CStringA rs{};
    Base64Encode(p, cb, rs);
    return rs;
}
EckInline CStringA Base64Encode(const CByteBuffer& rb) noexcept
{
    return Base64Encode(rb.Data(), rb.Size());
}
EckInline void Base64Encode(const CByteBuffer& rb, CStringA& rs) noexcept
{
    Base64Encode(rb.Data(), rb.Size(), rs);
}
ECK_NAMESPACE_END