#pragma once
#include "CRefBin.h"
#include "CRefStr.h"

ECK_NAMESPACE_BEGIN
namespace Priv
{
	inline constexpr BYTE Base64DecodeTable[]
	{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,

		0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
		0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

		0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
		0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
		0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
		0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,

		0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
		0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
		0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	constexpr inline char Base64EncodeTable[]{ "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" };
}

inline void Base64Decode(_In_reads_or_z_(cch) PCCH psz, int cch, CRefBin& rb)
{
	if (cch < 0)
		cch = (int)TcsLen(psz);
	int i{}, j{};
	size_t idxBin{ rb.Size() }, idxText{};
	BYTE temp[4];

	rb.PushBackNoExtra(cch / 4 * 3 + 3);
	while (cch-- && (psz[idxText] != '='))
	{
		temp[i++] = psz[idxText]; idxText++;
		if (i == 4)
		{
			for (i = 0; i < 4; i++)
				temp[i] = Priv::Base64DecodeTable[temp[i]];

			rb[idxBin++] = (temp[0] << 2) + ((temp[1] & 0x30) >> 4);
			rb[idxBin++] = ((temp[1] & 0xf) << 4) + ((temp[2] & 0x3c) >> 2);
			rb[idxBin++] = ((temp[2] & 0x3) << 6) + temp[3];

			i = 0;
		}
	}

	if (i)
	{
		for (j = i; j < 4; j++)
			temp[j] = 0;

		for (j = 0; j < 4; j++)
			temp[j] = Priv::Base64DecodeTable[temp[j]];

		rb[idxBin++] = (temp[0] << 2) + ((temp[1] & 0x30) >> 4);
		rb[idxBin++] = ((temp[1] & 0xf) << 4) + ((temp[2] & 0x3c) >> 2);
		rb[idxBin++] = ((temp[2] & 0x3) << 6) + temp[3];
	}
	rb.ReSize(idxBin);
}

EckInline void Base64Decode(_In_reads_or_z_(cch) const char8_t* psz, int cch, CRefBin& rb)
{
	Base64Decode((PCCH)psz, cch, rb);
}

inline void Base64Encode(_In_reads_bytes_(cb) PCVOID p_, size_t cb, CRefStrA& rs)
{
	PCBYTE p = (PCBYTE)p_;
	const auto pDst = rs.PushBackNoExtra(int(4 * ((cb + 2) / 3)));
	int i = 0;
	int j = 0;
	BYTE t3[3];
	BYTE t4[4];
	int pos = 0;

	while (cb--)
	{
		t3[i++] = *(p++);
		if (i == 3)
		{
			t4[0] = (t3[0] & 0xfc) >> 2;
			t4[1] = ((t3[0] & 0x03) << 4) + ((t3[1] & 0xf0) >> 4);
			t4[2] = ((t3[1] & 0x0f) << 2) + ((t3[2] & 0xc0) >> 6);
			t4[3] = t3[2] & 0x3f;

			for (i = 0; (i < 4); i++)
				pDst[pos++] = Priv::Base64EncodeTable[t4[i]];
			i = 0;
		}
	}

	if (i)
	{
		for (j = i; j < 3; j++)
			t3[j] = '\0';

		t4[0] = (t3[0] & 0xfc) >> 2;
		t4[1] = ((t3[0] & 0x03) << 4) + ((t3[1] & 0xf0) >> 4);
		t4[2] = ((t3[1] & 0x0f) << 2) + ((t3[2] & 0xc0) >> 6);
		t4[3] = t3[2] & 0x3f;

		for (j = 0; (j < i + 1); j++)
			pDst[pos++] = Priv::Base64EncodeTable[t4[j]];

		while ((i++ < 3))
			pDst[pos++] = '=';
	}
}

EckInline CRefBin Base64Decode(_In_reads_or_z_(cch) PCCH psz, int cch)
{
	CRefBin rb{};
	Base64Decode(psz, cch, rb);
	return rb;
}

EckInline CRefBin Base64Decode(_In_reads_or_z_(cch) const char8_t* psz, int cch)
{
	return Base64Decode(PCCH(psz), cch);
}

EckInline CRefBin Base64Decode(const CRefStrA& rs)
{
	return Base64Decode(rs.Data(), rs.Size());
}

EckInline void Base64Decode(const CRefStrA& rs, CRefBin& rb)
{
	Base64Decode(rs.Data(), rs.Size(), rb);
}

EckInline CRefStrA Base64Encode(_In_reads_bytes_(cb) PCVOID p, size_t cb)
{
	CRefStrA rs{};
	Base64Encode(p, cb, rs);
	return rs;
}

EckInline CRefStrA Base64Encode(const CRefBin& rb)
{
	return Base64Encode(rb.Data(), rb.Size());
}

EckInline void Base64Encode(const CRefBin& rb, CRefStrA& rs)
{
	Base64Encode(rb.Data(), rb.Size(), rs);
}
ECK_NAMESPACE_END